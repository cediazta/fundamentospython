<?xml version="1.0" encoding="UTF-8"?>
<cherrytree>
  <bookmarks list=""/>
  <node unique_id="1" master_id="0" name="Python" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1723531007" ts_lastsave="1770130084">
    <rich_text>## Tipos de Variables
	
	→ str (texto)
	→ int (numeros)
	→ float (numeros con decimales)
	→ complex (numeros complejos)
	→ boolean (true o false)
	→ char (caracteres individuales)
	

## Operadores Aritmeticos

	→ + , - , * , / (sumar , restar , multiplicar , dividir)
	→ // (division entera)
	→ ** (potencia)
	→ % (resto de una division)
	→ += , -= (suma al valor , resta al valor)
	
	
## Operadores de Comparacion

	→ &gt; , &lt; , == , != (mayor , menor , igual , distinto)
	→ &gt;= , &lt;= (mayor o igual , menor o igual)
	
	
## Operadores Logicos

	→ and (ambas condiciones se cumplen = True, sino sera False)
	→ or (sera True si solo se cumple una condicion)
	→ not (cambia el valor al booleano)


## Condicionales (control de Flujo)

	→ if , else (para 2 condiciones, si una se cumple hace una cosa y sino hace la otra)
	→ elif (para 3 condiciones o mas)


## Match y Case (determinar casos de distinto valor - parecido a if)

	→ match (rescata un valor de una variable y lo aplica a las opciones)
	→ case (son las opciones del match, clasifica los casos y depende del numero de la variable aplica a un caso u otro)


## Cadenas de texto y operaciones con string

	→  len (contar caracteres)
	→ .upper() (mayusculas)
	→ .lower() (minusculas)
	→ .title() (primera en mayusculas)
	→ .capitalize() (primera en mayuscula)
	→ .split() (convierte en lista)
	→ “ ”.join([variable1, variable2,...]) (concatena las variables añadiendo entre ellas el contenido que hay entre las comillas)
	→ .round(variable, decimales)
	→ .find() (Busca un texto dentro del string y nos devuelve su posicion, si no lo encuentra devuelve -1)	
	→ .rfind() (hace lo mismo que find() pero empezando por el final)
	→ .startswith() (devuelve True si el string comienza con un texto determinado)
	→ .endswith() (devuelve True si el string finaliza con un texto determinado) 
	→ .replace(antiguo, nuevo) ( reemplaza los caracteres antiguos con los nuevos de un string)
	→ .count(texto) (Cuenta el numero de veces que se repita un texto string)
	
	# Metodos para saber el tipo de contenido del string:
	→ .isdigit() (indica si es un numero el texto)
	→ .isalpha() (indica si el texto son letras)
	→ .isnum() (indica si el texto contiene caracteres numericos)
	→ .isupper() (indica si el texto esta en mayusculas)
	→ .islower() (indica si el texto esta en minusculas)
	→ .isalnum() (indica si el texto es letras y numeros)
	
	
	
## Listas [] y Tuplas ()

	→ Lista (sus valores son variables)
	→ Tupla (sus valores son constantes)
	
	→ .append() (añadir dato al final de la lista)
	→ .insert() (insertar dato en posicion especifica)
	→ .clear() (vaciar lista)
	→ .remove() (remover dato especifico)
	→ .copy() (copiar dato)
	→ .join() (añadir caracteres entre datos)
	→ .pop() (borrar dato de la lista pero manteniendolo en popped)
	→ .count() (contar elementos repetidos)
	→ .index() (localiizar posicion de un dato).
	→ .reverse() (invertir posiciones de la lista)
	→ .sort() (organizar lista en orden alfabetico) (si se le añade reverse=True organiza de la Z a la A)
	→ .extend() (unir varias listas) (lista_1.extend(lista_2)
		
	
# Bucle For (bucles con datos determinados y finaliza cuando termina la accion)

	→ break (rompe el bucle)
	→ continue (salta un paso del bucle y continua con el resto)


# Bucle While (se utiliza para ejecutar un bloque de codigo mientras cierta condicion de codigo sea True)

	→ break (rompe el bucle)
	→ continue (salta un paso del bucle y continua con el resto)
	
	
# Diccionarios {} (condicion de claves-valor)

 	→ .keys() (obtener las claves del diccionario)
 	→ .get() (obtener los valores del diccionario)
 	→ .values() (obtener los valores del diccionario)
 	→ .items() (obtener lista de tuplas claves-valor)	
 
 
# Sets {} (conjuntos de datos donde no se pueden repetir)
 
 	→ | (union de conjuntos)
    → &amp; (interseccion de conjuntos que tienen en comun)
    → - (operacion de diferencia entre conjuntos)

	→ .add() (añadir dato)
	→ .remove() (remover dato)
	

# Funciones def (bloques de codigo que se pueden utilizar llamandolos en cualquire momento del codigo)

	→ Variables Globales (consta fuera de la funcion)
	→ Variables Locales (consta solo dentro de la funcion)
 

## Funciones input y print 
 
  	→ input (recibir datos de entrada del usuario a traves de la consola)
 	→ print (imprimir informacion por consola)
 		→ sep = “-” (cambia la separacion de espacios en el simbolo que queramos)
		→ end = “€” (añade simbolos al final de la variable)
		
		
## Depuracion de errores en aplicaciones

	→ marcar a la izq del numero de linea “breakpoint”
	→ pulsar a la izq “Run and debug”
	→ volvemos a pulsar en “Run and debug” y seleccionamos en archivo actual
	→ con el boton de arriba “Step over” vamos saltando lineas y observando a la izquierda el progreso del programa line a linea.


## Librerias

	→ import Libreria
		→ la llamada seria libreria.metodo1()
	→ from libreria import metodo1(), metodo2()
		→ la llamada seria solo al metodo (metodo1())
		
## Metodos
	→ __init__ (Constructor)
	→ __str__ (sobrescribir por como lo queramos)
	
	# Herencias
	→ super() (recuperar un atributo de un metodo del main)



*** LIBRERIAS ***
		
## Tkinter

→ from Tkinter import * (se importa Tkinter completo)
→ import Tkinter (se importa el modulo tkinter)

→ TK() (Creacion de ventana)
→ .title() (añadir titulo a la ventana)
→ .geometry("800x600+550+120) (tamaño de la ventana 800x600 = tamaño de la ventana / 550+120 posicion de la ventana en pantalla)
→ Label(variable, text=" ") (Creacion de etiqueta dentro de la ventana)
→ .grid(row=0, column=0) (posicionamiento en ventana de la etiqueta creada con Label)
→ .mainloop() (Bucle de ejecucion de la ventana para que siempre este visible)
→ .pack() (administrador que organiza los widgets en bloques)
→ 



## Widgets

→ Entry (crear cuadro de texto)(misma funcion que input pero en gui)
   ⇒ .get() (retorna el texto)
   ⇒ .insert(posicion, texto) (texto que se mostrara en el cuadro de texto)
   ⇒ .bind(evento, controlador) (evento puede ser un boton de raton.. de teclado.../controlador es una accion)

→ Button(variable tkinter, text=" ", command=Evento) (Crea un boton con tkinter con un texto y una accion especifica)







 
 

	
	
	







</rich_text>
  </node>
  <node unique_id="3" master_id="0" name="SQL" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1770242417" ts_lastsave="1770312564">
    <rich_text>## CONSULTAS DE AGRUPACION (MISMA TABLA)

• SINTAXIS
</rich_text>
    <rich_text foreground="#569cd6">SELECT</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#9cdcfe">columna1</rich_text>
    <rich_text foreground="#cccccc">, </rich_text>
    <rich_text foreground="#9cdcfe">columna2</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#569cd6">FROM</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#9cdcfe">tabla</rich_text>
    <rich_text foreground="#cccccc">;</rich_text>
    <rich_text>
Ej: </rich_text>
    <rich_text foreground="#569cd6">SELECT</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#9cdcfe">nombre</rich_text>
    <rich_text foreground="#cccccc">, </rich_text>
    <rich_text foreground="#9cdcfe">apellido</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#569cd6">FROM</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#9cdcfe">clientes</rich_text>
    <rich_text foreground="#cccccc">;</rich_text>
    <rich_text>

• DISTINCT (SOLO MUESTRA LOS CAMPOS DISTINTOS)
Ej: </rich_text>
    <rich_text foreground="#569cd6">SELECT</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#569cd6">DISTINCT</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#9cdcfe">nombre</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#569cd6">FROM</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#9cdcfe">clientes</rich_text>
    <rich_text foreground="#cccccc">;</rich_text>
    <rich_text>
 - Muestra los nombres sin repetir.
 
• WHERE (especificar datos, algo concreto)
Ej: </rich_text>
    <rich_text foreground="#569cd6">SELECT</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#d4d4d4">*</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#569cd6">FROM</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#9cdcfe">doctor</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#569cd6">WHERE</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#9cdcfe">hospital_cod</rich_text>
    <rich_text> </rich_text>
    <rich_text foreground="#d4d4d4">=</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#b5cea8">22</rich_text>
    <rich_text foreground="#cccccc">;</rich_text>
    <rich_text>
 - Muestra todo de la tabla DOCTOR que tenga 22 en la columna HOSPITAL_COD.
 
• ORDER BY (Orden descendente)
Ej: </rich_text>
    <rich_text foreground="#569cd6">SELECT</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#d4d4d4">*</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#569cd6">FROM</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#9cdcfe">doctor</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#569cd6">ORDER</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#569cd6">BY</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#9cdcfe">hospital_cod</rich_text>
    <rich_text foreground="#cccccc">;</rich_text>
    <rich_text>
 - Ordena la columna HOSPITAL_COD en orden descendente.
 
• ORDER BY (Orden ascendente)
Ej: </rich_text>
    <rich_text foreground="#569cd6">SELECT</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#d4d4d4">*</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#569cd6">FROM</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#9cdcfe">doctor</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#569cd6">ORDER</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#569cd6">BY</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#9cdcfe">hospital_cod</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#569cd6">ASC</rich_text>
    <rich_text foreground="#cccccc">;</rich_text>
    <rich_text>
 - Ordena la columna HOSPITAL_COD en orden ascendente.

• LIKE (damos un criterio de busqueda variable)
•Ej: </rich_text>
    <rich_text foreground="#569cd6">SELECT</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#9cdcfe">apellido</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#569cd6">FROM</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#9cdcfe">doctor</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#569cd6">WHERE</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#9cdcfe">especialidad</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#569cd6">LIKE</rich_text>
    <rich_text foreground="#cccccc"> </rich_text>
    <rich_text foreground="#ce9178">'%logia'</rich_text>
    <rich_text foreground="#cccccc">;</rich_text>
    <rich_text>
 - Muestra los APELLIDOS de la tabla DOCTOR cuya ESPECIALIDAD contenga ‘%logia’ (% cualquier caracter)







## CONSULTAS COMBINADAS (DISTINTAS TABLAS)

• SINTAXIS
SELECT tabla1.campo, tabla1.campo2, tabla2.campo1, tabla2.campo2 FROM tabla1 INNER JOIN tabla2 ON tabla1.camporelacion = tabla2.camporelacion;
Ej: SELECT emp.apellido, emp.oficio, dept.dnombre, dept.loc FROM emp INNER JOIN dept ON emp.dept_no = emp.dept_no;
-- Miestra el apellido, oficio, nombre de departamento, localidad de los empleados de las tablas dept y emp.

• WHERE
ej: SELECT emp.apellIdo, emp.oficio, dept.dnombre, dept.loc FROM emp INNER JOIN dept on emp.dept_no = dept.dept_no WHERE dept.loc ='SEVILLA';
-- Miestra el apellido, oficio, nombre de departamento, localidad de los empleados de las tablas dept y emp y solo mostrar los que su localidad sea Sevilla.

• AS (alias)
Ej: SELECT e.apellIdo, e.oficio, d.dnombre, d.loc FROM emp e INNER JOIN dept d on e.dept_no = d.dept_no WHERE d.loc ='SEVILLA';
-- Crea un alias a las 2 tablas y se sustituye como nombre de tabla al ingresar los campos.





## CONSULTAS COMBINADAS + CONSULTAS DE AGRUPACION
Ej: SELECT COUNT(*) AS personas, dept.dnombre FROM emp INNER JOIN dept on emp.dept_no = dept.dept_no GROUP BY dept.dnombre;
-- Muestra el numero de personas por cada nombre de departamento de los empleados.

•  JOIN
 → INNER JOIN: (Muestra los resultados que combinen entre las dos tablas).
 Ej: SELECT emp.apellido, emp.oficio, dept.dnombre, dept.loc FROM emp INNER JOIN dept ON emp.dept_no = dept.dept_no;
 
 → LEFT JOIN: (Muestra los resultados que combinen entre las dos tablas y tambien los que no 				combinen de la tabla de la izquierda). (ES LA TABLA ANTES DEL JOIN)
 Ej: SELECT emp.apellido, emp.oficio, dept.dnombre, dept.loc FROM emp LEFT JOIN dept ON emp.dept_no = dept.dept_no;
 
 → RIGHT JOIN: (Muestra los resultados que combinen entre las dos tablas y tambien los que no 				combinen de la tabla de la derecha). (ES LA TABLA DESPUES DEL JOIN)
 Ej: SELECT emp.apellido, emp.oficio, dept.dnombre, dept.loc FROM emp RIGHT JOIN dept ON emp.dept_no = dept.dept_no;
 
 → FULL JOIN: (Muestra los resultados de las dos tablas combinen o no combinen). (MUESTRA TODOS)
 Ej: SELECT emp.apellido, emp.oficio, dept.dnombre, dept.loc FROM emp FULL JOIN dept ON emp.dept_no = dept.dept_no;
 
 → CROSS JOIN: (Muestra el producto cartesiano). (NO SE UTILIZA “ON")
 Ej: SELECT emp.apellido, emp.oficio, dept.dnombre, dept.loc FROM emp CROSS JOIN dept;
 
 

• INNER JOIN (CON LAS TABLAS QUE QUERAMOS)
Ej: select tabla1.campo1, tabla1.campo2, tabla2.campo1, tabla2.campo2, tabla3.campo1, tabla3.campo2 FROM tabla1 INNER JOIN tabla2 on tabla1.camporelacion= tabla2.camporelacion INNER JOIN tabla3 on tabla1.camporelacion = tabla3.camporelacion

→ Si hay mas campos relacionados entre si, se pondria conun AND
Ej: SELECT plantilla.apellido, plantilla.funcion, hospital.nombre, hospital.direccion, sala.nombre FROM plantilla INNER JOIN hospital ON plantilla.hospital_cod = hospital.hospital_cod INNER JOIN sala ON hospital.hospital_cod = sala.hospital_cod AND plantilla.sala_cod = sala.sala_cod;

</rich_text>
  </node>
  <node unique_id="2" master_id="0" name="Oracle SQL" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1770130084" ts_lastsave="1770242417">
    <rich_text>User: SYSTEM
Password: oracle
Port: 1521
SSID: FREEPDB1


-- PODEMOS TENER VARIAS CONSULTAS EN ESTE SCRIPT
-- SOLAMENTE SE EJECUTA EN LA QUE ESTEMOS POSICIONADOS (CNTRL + ENTER)
-- NO EXISTE DIFERENCIA CASE SENSITIVE (MAYUS O MINUS)
-- EL * SE UTILIZA PARA INDICAR TODAS LAS COLUMNAS DE UNA TABLA
-- select COLUMNA1, COLUMNA2 from TABLA
select * from DEPT;
select * from EMP;

-- EXISTEN CONSULTAS QUE SON MAS OPTIMAS QUE OTRAS Y DEVUELVEN LO MISMO
select DEPT_NO, DNOMBRE, LOC FROM DEPT;

-- ORDENAR LOS DATOS: order by CAMPO
select * from EMP order by SALARIO desc;
select * from EMP order by OFICIO desc;

-- FILTROS DE CONSULTAS
-- permiten filtrar registros por columnas en sus datos, utilizan el operador "where"
-- utilizan operadores condicionales, si el dato a filtrar no es un numero, se utilizan las comillas simples ''
-- Algunos son diferentes a PYTHON
/*
= IGUAL
&lt;&gt; DISTINTO
&gt; MAYOR
&gt;= MAYOR O IGUAL
&lt; MENOR
&lt;= MENOR O IGUAL
*/
-- mostrar los empleados del departamento 10
-- where CAMPO = VALOR
select * from EMP where DEPT_NO = 10;
-- mostrar todos los empleados con oficio director
-- Oracle diferencian en sus datos string
select * from EMP where OFICIO = 'DIRECTOR';
select * from EMP where OFICIO = 'director';
-- mostrar los empleados que sean distintos al departamento 10
select * from EMP where DEPT_NO &lt;&gt; 10;
-- = select * from EMP where DEPT_NO != 10;

-- OPERADORES RELACIONALES
-- permiten filtrar por mas de una condicion, solamente podemos tener un where
-- AND: todas las condiciones se deben cumplir
-- OR: devuelven registros de cada condicion
-- NOT: negacion de una condicion
-- Mostrar todos los empleados con oficion director y un salario mayor a 300.000
select * from EMP where OFICIO='DIRECTOR' or SALARIO &gt; 300000;
-- Mostrar todos los empleados que sean del departamento 10 y el departamento 20
select * from EMP where DEPT_NO=10 or DEPT_NO=20;
-- Mostrar todos los empleados que no sean del departamento 20
select * from EMP where not DEPT_NO = 20;
-- = select * from EMP where DEPT_NO &lt;&gt; 20;

-- Existen otra serie de operadores de comparacion ademas de los basicos
-- "between" busca entre dos rangos inclusive
-- Mostrar todos los empleados que tengan un salario entre 123500 y 318500
select * from EMP where SALARIO between 123500 and 318500;
select * from EMP where SALARIO &gt;= 123500 and SALARIO &lt;= 318500;

-- Operador "IN" permite buscar entre diferentes valores de un mismo campo
-- Mostrar todos los empleados del departamento 10 y 20
select * from EMP where DEPT_NO in (10, 20, 30);
-- = select * from EMP where DEPT_NO = 10 or DEPT_NO = 20 or DEPT_NO = 30;

-- Operador "NOT IN" que busca entre diferentes valores de un mismo campo y devuelve los que correspondan
-- Mostrar todos los empleados que no esten en el departamento 10 y 20
select * from EMP where NOT DEPT_NO in (10,20); -- ESTO ES UNA NEGACION, NO EFICIENTE
select * from EMP where DEPT_NO not in (10,20);

-- Tenemos un operador que nos permite hacer busquedas dentro de textos.
-- Es el operador "like" y utiliza caravteristicas especiales para las busquedas.
    -- ? Busca si el caracter es un numero
    -- _ Cualquier unico caracter
    -- % Cualquier caracter y cualquier tamaño
-- Mostrar todos los empleados cuyo apellido comienza en "s"
select * from EMP where APELLIDO like 's%';
-- Mostrar todos los empleados cuyo apellido comienza en "s" y finalicen en "a"
select * from EMP where APELLIDO like 's%a';
-- Mostrar todos los empleados cuyo apellido tenga 4 letras
select * from EMP where APELLIDO like '____';

-- Clausula "distinct" elimina datos repetidos de la consulta
-- Se suele utilizar con pocos campos
select distinct OFICIO from EMP;

-- Campos calculados. Son columnas que no existen en la tabla y que podemos generar con una consulta
-- Los campos calculados siempre deben tener un ALIAS, se interpreta con "as"
select APELLIDO, OFICIO, SALARIO + COMISION as TOTALSALARIO from EMP;

-- no podemos utilizar where con campos calculador (mentira).
    -- Where filtra sobre la tabla
    -- Si queremos filtrar sobre un campo calculado, debemos escribir el calculo de nuevo para el where
select APELLIDO, OFICIO, SALARIO + COMISION as TOTAL from EMP where (SALARIO + COMISION) &gt;= 300000;
-- si podemos utilizar order by con campos calculados.
    -- "order by" ordena sobre el cursor
select APELLIDO, OFICIO, SALARIO + COMISION as TOTAL from EMP order by TOTAL;

-- CONSULTAS DE AGRUPACION

( CONTENIDO DEL WORD DE CLASE)


-- Mostrar el numero de empleados de la tabla
select count(*) as REGISTROS from EMP;

-- Podemos combinar varias funciones en una misma consulta
-- Mostrar numero de empleados y la suma salarial de todo
select count(*) as REGISTROS, sum(SALARIO) as SUMASALARIAL, MAX(SALARIO) as AL from EMP;

-- Queremos saber el numero de empleados por cada oficio
select count(*) as EMPLEADOS, OFICIO from EMP group by OFICIO;

-- Mostrar el Maximo salario, numero de personas por cada oficio y por cada departamento.
select max(SALARIO) as MAXIMOSALARIO, count(*) as PERSONAS, OFICIO, DEPT_NO from EMP group by OFICIO, DEPT-NO;


(ESTRUCTURAS WORD)

-- Mostrar el numero de personas por cada OFICIO
-- pero solamente mostrando DIRECTOR Y ANALISTA
select count(*) as PERSONAS,OFICIO from EMP where OFICIO in ('ANALISTA', ‘DIRECTOR’) group by OFICIO;

-- Mostrar el numero de empleados por cada oficio pero solamente mostrando los oficios donde tengamos mas de 2 personas trabajando
select count (*) as PERSONAS, OFICIO from EMP group by OFICIO having count(*) &gt; 2;

-- Mostrar la suma salarial por cada oficio solamente de las personas que tengan una comision mayor a 0.
select sum(SALARIO) as SUMASALARIAL, OFICIO from EMP where comision &gt; 0 group by OFICIO;

-- Mostrar la suma salarial por cada oficio solamente de las personas que tengan una comision mayor a 0 y cuya suma salarial sea mayot a 51500.
select sum(SALARIO) as SUMASALARIAL, OFICIO from EMP where comision &gt; 0 group by OFICIO having sum(SALARIO) &gt; 51500;


</rich_text>
  </node>
</cherrytree>
